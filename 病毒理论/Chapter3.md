
# 第三章 文件系统

## FAT12

### FAT12格式

![Untitled](病毒/Untitled%2028.png))

### 文件存储方式

- 按扇区存储，通过链表组织
- 结束标志AA55，改成其他值还可以正常工作
1. 引导记录格式

![Untitled](病毒/Untitled%2029.png))

![Untitled](病毒/Untitled%2030.png))

- 结束标志好像对于dos没有什么用
- 介质描述符：修改之后盘无效了
- 修改fat大小，导致根目录无法正常访问
- 最开始的jmp：EB 3C 90(jmp 62+nop)，引导代码从62开始
1. 系统引导
    - 第一个扇区被拷贝到内存7c00h处，并执行
2. 定位文件
    - 文件分配的最小单位是一个簇
    - 一个簇号占用12bits，即一个半字节
    - 用户的簇号从簇2开始分配，
    
   ![Untitled](病毒/Untitled%2031.png))
    
   ![Untitled](病毒/Untitled%2032.png))
    
3. 如何找到文件
    
   ![Untitled](病毒/Untitled%2033.png))
    
    - 名字的结束以空格表示结束，即0x20
    - 根目录大小有限制
    - 根目录存储特殊的根目录记录，记录着卷标名
    - 一个目录项记录长度为32字节
4. 定位多层文件
    - 根目录的簇号是0或1都可以。
5. 获取大于一扇区的文件
6. 删除文件
    - 回收已用簇
    - 实际文件扇区的内容不用修改，这也是数据删除后可以恢复的原因。
    - 对应文件的目录项首字节改为E5
7. 恢复文件
    - 恢复多个簇的文件：怎么恢复fat表呢
    - 恢复只有一个簇的文件：对应fat表的值改为fff，目录项首字节改回来
8. 新增目录项
    - 查找可用目录项
    - 分配簇

## FAT16

> 主要区别在于fat表项不是12bits而是16bits组成，即2字节
> 

![Untitled](病毒/Untitled%2034.png))

## FAT 32

- 出于FAT16不支持大分区、单位簇容量大以至于空间急剧浪费等缺点设计的

![Untitled](病毒/Untitled%2035.png))

- 取消根文件目录区
- 数据区起始扇区计算
    
   ![Untitled](病毒/Untitled%2036.png))
    

### 目录项

- Fat32为每个登录的名字都会分配一个短文件名目录项，其中包括了首簇号，文件大小等基本属性。除了短名目录项，还会分配一个目录项（但第一个字节用e5删除表示，但它不是表示删除，而是没有生效的长名项）。如果该项不够存名字，还会再分配一个长名目录项

![Untitled](病毒/Untitled%2037.png))

![Untitled](病毒/Untitled%2038.png))

![Untitled](病毒/Untitled%2039.png))

![Untitled](病毒/Untitled%2040.png))

![Untitled](病毒/Untitled%2041.png))

## 硬盘数据结构

分区划分以柱面为单位，一个柱面不能属于两个分区。

### 分区记录表

![Untitled](病毒/Untitled%2042.png))

### 主引导记录

![Untitled](病毒/Untitled%2043.png))

![Untitled](病毒/Untitled%2044.png))

### 找到特定分区

- 头部有jmp eb
- 尾部有结束符55aa

### 扩展分区

![Untitled](病毒/Untitled%2045.png))

- 偏移相对于MBR或EBR
- 引导扇区的主引导记录为全0
- 只有最后一个分区项能够指向EBR，其余分区项都直接指向盘区

## 硬盘引导过程

![Untitled](病毒/Untitled%2046.png))

- 操作系统相关的引导代码在其分区的引导扇区（即激活分区）
- 硬盘可以引导多系统。要引导多系统必须用专门的引导程序替换MBR，这样替换后的代码执行时可让用户选择启动那个分区
- 在之前的实验中，C盘，即第一个主分区是系统盘，扮演的激活分区。下面看之前查到的MBR中的第一条分区表项。第一个字节正是0x80.而第2个记录的第一字节就是0，非激活。
- 7C00处的代码来自于主引导扇区MBR

![Untitled](病毒/Untitled%2047.png))

1. Bios自检、初始化，然后控制交给MBR
2. MBR找激活分区（或者叫活动分区，即哪个分区装了操作系统）
3. MBR找到的活动分区里的引导记录开始运行，称为OBR

[《操作系统真象还原》二、MBR主引导记录](https://zhuanlan.zhihu.com/p/358796403)

### 修改活动分区

修改MBR的分区项，将第二项作为激活分区，第二项指向EBR，将EBR首部的一个扇区替换为自己的引导代码，成功启动自己的操作系统。

改回来后，D盘不再受Dos管辖

不存在激活分区则放弃启动。

## MBR引导代码分析

- 会将自己的代码拷贝到600h执行

![Untitled](病毒/Untitled%2048.png))

- 操作系统的boot在7C00h中执行
- 从61dh开始的代码，用于解析分区表项
    - 对分区表项第一字节的值只能是80或0.
    - 多个激活分区会选择第一个作为激活？
    - 加载激活分区的引导扇区后，判断了是否扇区最后两字节是55 aa，不是则拒绝往下执行引导代码(将jnz指令nop，可以使其不检查激活扇区的55 AA)
    - 在执行激活分区的引导代码前通过si传递了刚才找到的激活分区表项的地址。
    传递了激活分区表项首址，估计供真正的os引导代码使用因为，必须计算逻辑盘的真正的起始位置。文件系统并没有占领整个硬盘，必须给出其起始位置方可。而这些信息起始头，结束头，起始和结束扇区，track，相对起始偏移等都在分区表项中。这些，必须告诉os的loader。这通过si告知了。

## 引导制作

![Untitled](病毒/Untitled%2049.png))

## 有趣的发现省流

- MBR的引导代码将激活分区表项首址用si传递给激活分区的引导代码
- 但，激活分区的引导代码并没用它，而是用分区时写入的隐藏扇区定位出自己的起始位置。但也因此激活分区只能是主分区（隐藏扇区只能定位出到EBR的偏移，而只有MBR因其就在硬盘开始，所以可知其基址，其它EBR的基址除了从MBR分区表开始推，别无它法）。

## 硬盘逻辑锁

![Untitled](病毒/Untitled%2050.png))

- 直接将MBR第二项指向自己，无法生效
- 将EBR的第一项破坏，生效
- 分区表项除了相对扇区数可能还有其他定位方式：
    - ？总扇区数（前一个分区找到之后，通过该项就能找到下一个分区），但是结果貌似是和他无关
    - 起始磁头号、扇区号、柱面号
        
       ![Untitled](病毒/Untitled%2051.png))
        
       ![Untitled](病毒/Untitled%2052.png))
        
- 系统防止逻辑锁的方式：判断逻辑盘的个数，超过多少个就结束。
- 所有分区的描述信息都是同一个

![Untitled](病毒/Untitled%2053.png))