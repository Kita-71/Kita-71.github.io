import{_ as t,c as l,o as i,a1 as a}from"./chunks/framework.BwTyoF0R.js";const e="/assets/Untitled%2028.Cu8tQEBy.png",s="/assets/Untitled%2029.BY6b2nU-.png",n="/assets/Untitled%2030.DdYMqkgK.png",r="/assets/Untitled%2031.i4fe_ZC9.png",p="/assets/Untitled%2032.BUaz9eyN.png",o="/assets/Untitled%2033.DEp4J4Jr.png",d="/assets/Untitled%2034.BmL9YRTR.png",c="/assets/Untitled%2035.Dm7OhaOL.png",h="/assets/Untitled%2036.B3OCcVPV.png",m="/assets/Untitled%2037.C_oyvx2W.png",u="/assets/Untitled%2038.B9z7vdoG.png",_="/assets/Untitled%2039.NuWP8v8g.png",g="/assets/Untitled%2040.DilfKsUu.png",U="/assets/Untitled%2041.xDmnzJ5T.png",b="/assets/Untitled%2042.DK2pYrf2.png",f="/assets/Untitled%2043.BkepYkZy.png",q="/assets/Untitled%2044.C2OE0mvC.png",B="/assets/Untitled%2045.10OkGCxj.png",k="/assets/Untitled%2046.1vQYkdpN.png",R="/assets/Untitled%2047.X_8v3spo.png",x="/assets/Untitled%2048.Bi2glwmQ.png",P="/assets/Untitled%2049.CRtY2zGF.png",C="/assets/Untitled%2050.Bb6fz-S7.png",T="/assets/Untitled%2051.BEN1PMsU.png",M="/assets/Untitled%2052.vLPY-1Yc.png",A="/assets/Untitled%2053.CBkai4TI.png",y=JSON.parse('{"title":"第三章 文件系统","description":"","frontmatter":{},"headers":[],"relativePath":"病毒理论/Chapter3.md","filePath":"病毒理论/Chapter3.md"}'),E={name:"病毒理论/Chapter3.md"},F=a('<h1 id="第三章-文件系统" tabindex="-1">第三章 文件系统 <a class="header-anchor" href="#第三章-文件系统" aria-label="Permalink to &quot;第三章 文件系统&quot;">​</a></h1><h2 id="fat12" tabindex="-1">FAT12 <a class="header-anchor" href="#fat12" aria-label="Permalink to &quot;FAT12&quot;">​</a></h2><h3 id="fat12格式" tabindex="-1">FAT12格式 <a class="header-anchor" href="#fat12格式" aria-label="Permalink to &quot;FAT12格式&quot;">​</a></h3><p><img src="'+e+'" alt="Untitled">)</p><h3 id="文件存储方式" tabindex="-1">文件存储方式 <a class="header-anchor" href="#文件存储方式" aria-label="Permalink to &quot;文件存储方式&quot;">​</a></h3><ul><li>按扇区存储，通过链表组织</li><li>结束标志AA55，改成其他值还可以正常工作</li></ul><ol><li>引导记录格式</li></ol><p><img src="'+s+'" alt="Untitled">)</p><p><img src="'+n+'" alt="Untitled">)</p><ul><li>结束标志好像对于dos没有什么用</li><li>介质描述符：修改之后盘无效了</li><li>修改fat大小，导致根目录无法正常访问</li><li>最开始的jmp：EB 3C 90(jmp 62+nop)，引导代码从62开始</li></ul><ol><li><p>系统引导</p><ul><li>第一个扇区被拷贝到内存7c00h处，并执行</li></ul></li><li><p>定位文件</p><ul><li>文件分配的最小单位是一个簇</li><li>一个簇号占用12bits，即一个半字节</li><li>用户的簇号从簇2开始分配，</li></ul><p><img src="'+r+'" alt="Untitled">)</p><p><img src="'+p+'" alt="Untitled">)</p></li><li><p>如何找到文件</p><p><img src="'+o+'" alt="Untitled">)</p><ul><li>名字的结束以空格表示结束，即0x20</li><li>根目录大小有限制</li><li>根目录存储特殊的根目录记录，记录着卷标名</li><li>一个目录项记录长度为32字节</li></ul></li><li><p>定位多层文件</p><ul><li>根目录的簇号是0或1都可以。</li></ul></li><li><p>获取大于一扇区的文件</p></li><li><p>删除文件</p><ul><li>回收已用簇</li><li>实际文件扇区的内容不用修改，这也是数据删除后可以恢复的原因。</li><li>对应文件的目录项首字节改为E5</li></ul></li><li><p>恢复文件</p><ul><li>恢复多个簇的文件：怎么恢复fat表呢</li><li>恢复只有一个簇的文件：对应fat表的值改为fff，目录项首字节改回来</li></ul></li><li><p>新增目录项</p><ul><li>查找可用目录项</li><li>分配簇</li></ul></li></ol><h2 id="fat16" tabindex="-1">FAT16 <a class="header-anchor" href="#fat16" aria-label="Permalink to &quot;FAT16&quot;">​</a></h2><blockquote><p>主要区别在于fat表项不是12bits而是16bits组成，即2字节</p></blockquote><p><img src="'+d+'" alt="Untitled">)</p><h2 id="fat-32" tabindex="-1">FAT 32 <a class="header-anchor" href="#fat-32" aria-label="Permalink to &quot;FAT 32&quot;">​</a></h2><ul><li>出于FAT16不支持大分区、单位簇容量大以至于空间急剧浪费等缺点设计的</li></ul><p><img src="'+c+'" alt="Untitled">)</p><ul><li><p>取消根文件目录区</p></li><li><p>数据区起始扇区计算</p><p><img src="'+h+'" alt="Untitled">)</p></li></ul><h3 id="目录项" tabindex="-1">目录项 <a class="header-anchor" href="#目录项" aria-label="Permalink to &quot;目录项&quot;">​</a></h3><ul><li>Fat32为每个登录的名字都会分配一个短文件名目录项，其中包括了首簇号，文件大小等基本属性。除了短名目录项，还会分配一个目录项（但第一个字节用e5删除表示，但它不是表示删除，而是没有生效的长名项）。如果该项不够存名字，还会再分配一个长名目录项</li></ul><p><img src="'+m+'" alt="Untitled">)</p><p><img src="'+u+'" alt="Untitled">)</p><p><img src="'+_+'" alt="Untitled">)</p><p><img src="'+g+'" alt="Untitled">)</p><p><img src="'+U+'" alt="Untitled">)</p><h2 id="硬盘数据结构" tabindex="-1">硬盘数据结构 <a class="header-anchor" href="#硬盘数据结构" aria-label="Permalink to &quot;硬盘数据结构&quot;">​</a></h2><p>分区划分以柱面为单位，一个柱面不能属于两个分区。</p><h3 id="分区记录表" tabindex="-1">分区记录表 <a class="header-anchor" href="#分区记录表" aria-label="Permalink to &quot;分区记录表&quot;">​</a></h3><p><img src="'+b+'" alt="Untitled">)</p><h3 id="主引导记录" tabindex="-1">主引导记录 <a class="header-anchor" href="#主引导记录" aria-label="Permalink to &quot;主引导记录&quot;">​</a></h3><p><img src="'+f+'" alt="Untitled">)</p><p><img src="'+q+'" alt="Untitled">)</p><h3 id="找到特定分区" tabindex="-1">找到特定分区 <a class="header-anchor" href="#找到特定分区" aria-label="Permalink to &quot;找到特定分区&quot;">​</a></h3><ul><li>头部有jmp eb</li><li>尾部有结束符55aa</li></ul><h3 id="扩展分区" tabindex="-1">扩展分区 <a class="header-anchor" href="#扩展分区" aria-label="Permalink to &quot;扩展分区&quot;">​</a></h3><p><img src="'+B+'" alt="Untitled">)</p><ul><li>偏移相对于MBR或EBR</li><li>引导扇区的主引导记录为全0</li><li>只有最后一个分区项能够指向EBR，其余分区项都直接指向盘区</li></ul><h2 id="硬盘引导过程" tabindex="-1">硬盘引导过程 <a class="header-anchor" href="#硬盘引导过程" aria-label="Permalink to &quot;硬盘引导过程&quot;">​</a></h2><p><img src="'+k+'" alt="Untitled">)</p><ul><li>操作系统相关的引导代码在其分区的引导扇区（即激活分区）</li><li>硬盘可以引导多系统。要引导多系统必须用专门的引导程序替换MBR，这样替换后的代码执行时可让用户选择启动那个分区</li><li>在之前的实验中，C盘，即第一个主分区是系统盘，扮演的激活分区。下面看之前查到的MBR中的第一条分区表项。第一个字节正是0x80.而第2个记录的第一字节就是0，非激活。</li><li>7C00处的代码来自于主引导扇区MBR</li></ul><p><img src="'+R+'" alt="Untitled">)</p><ol><li>Bios自检、初始化，然后控制交给MBR</li><li>MBR找激活分区（或者叫活动分区，即哪个分区装了操作系统）</li><li>MBR找到的活动分区里的引导记录开始运行，称为OBR</li></ol><p><a href="https://zhuanlan.zhihu.com/p/358796403" target="_blank" rel="noreferrer">《操作系统真象还原》二、MBR主引导记录</a></p><h3 id="修改活动分区" tabindex="-1">修改活动分区 <a class="header-anchor" href="#修改活动分区" aria-label="Permalink to &quot;修改活动分区&quot;">​</a></h3><p>修改MBR的分区项，将第二项作为激活分区，第二项指向EBR，将EBR首部的一个扇区替换为自己的引导代码，成功启动自己的操作系统。</p><p>改回来后，D盘不再受Dos管辖</p><p>不存在激活分区则放弃启动。</p><h2 id="mbr引导代码分析" tabindex="-1">MBR引导代码分析 <a class="header-anchor" href="#mbr引导代码分析" aria-label="Permalink to &quot;MBR引导代码分析&quot;">​</a></h2><ul><li>会将自己的代码拷贝到600h执行</li></ul><p><img src="'+x+'" alt="Untitled">)</p><ul><li>操作系统的boot在7C00h中执行</li><li>从61dh开始的代码，用于解析分区表项 <ul><li>对分区表项第一字节的值只能是80或0.</li><li>多个激活分区会选择第一个作为激活？</li><li>加载激活分区的引导扇区后，判断了是否扇区最后两字节是55 aa，不是则拒绝往下执行引导代码(将jnz指令nop，可以使其不检查激活扇区的55 AA)</li><li>在执行激活分区的引导代码前通过si传递了刚才找到的激活分区表项的地址。 传递了激活分区表项首址，估计供真正的os引导代码使用因为，必须计算逻辑盘的真正的起始位置。文件系统并没有占领整个硬盘，必须给出其起始位置方可。而这些信息起始头，结束头，起始和结束扇区，track，相对起始偏移等都在分区表项中。这些，必须告诉os的loader。这通过si告知了。</li></ul></li></ul><h2 id="引导制作" tabindex="-1">引导制作 <a class="header-anchor" href="#引导制作" aria-label="Permalink to &quot;引导制作&quot;">​</a></h2><p><img src="'+P+'" alt="Untitled">)</p><h2 id="有趣的发现省流" tabindex="-1">有趣的发现省流 <a class="header-anchor" href="#有趣的发现省流" aria-label="Permalink to &quot;有趣的发现省流&quot;">​</a></h2><ul><li>MBR的引导代码将激活分区表项首址用si传递给激活分区的引导代码</li><li>但，激活分区的引导代码并没用它，而是用分区时写入的隐藏扇区定位出自己的起始位置。但也因此激活分区只能是主分区（隐藏扇区只能定位出到EBR的偏移，而只有MBR因其就在硬盘开始，所以可知其基址，其它EBR的基址除了从MBR分区表开始推，别无它法）。</li></ul><h2 id="硬盘逻辑锁" tabindex="-1">硬盘逻辑锁 <a class="header-anchor" href="#硬盘逻辑锁" aria-label="Permalink to &quot;硬盘逻辑锁&quot;">​</a></h2><p><img src="'+C+'" alt="Untitled">)</p><ul><li><p>直接将MBR第二项指向自己，无法生效</p></li><li><p>将EBR的第一项破坏，生效</p></li><li><p>分区表项除了相对扇区数可能还有其他定位方式：</p><ul><li><p>？总扇区数（前一个分区找到之后，通过该项就能找到下一个分区），但是结果貌似是和他无关</p></li><li><p>起始磁头号、扇区号、柱面号</p><p><img src="'+T+'" alt="Untitled">)</p><p><img src="'+M+'" alt="Untitled">)</p></li></ul></li><li><p>系统防止逻辑锁的方式：判断逻辑盘的个数，超过多少个就结束。</p></li><li><p>所有分区的描述信息都是同一个</p></li></ul><p><img src="'+A+'" alt="Untitled">)</p>',59),D=[F];function v(Y,z,N,O,S,j){return i(),l("div",null,D)}const J=t(E,[["render",v]]);export{y as __pageData,J as default};
