import{_ as l,c as i,o as t,a1 as a}from"./chunks/framework.BwTyoF0R.js";const e="/assets/Untitled.D1IJu42u.png",s="/assets/Untitled%201.qzHpbx3R.png",o="/assets/Untitled%202.CjYJDT9e.png",r="/assets/Untitled%203.DZBFQl2n.png",p="/assets/Untitled%204.HW-ovK5Y.png",n="/assets/Untitled%205.SaJ0KRHi.png",d="/assets/Untitled%206.rmRLPn7o.png",u="/assets/Untitled%207.BTPD_e8O.png",c="/assets/Untitled%208.Dc28pLy9.png",_="/assets/Untitled%209.DZsMXszS.png",h="/assets/Untitled%2010.D00OCWl6.png",g="/assets/Untitled%2011.CdMfJL66.png",m="/assets/Untitled%2012.DnUI55Ag.png",U="/assets/Untitled%2013.BT_ZgoCG.png",b="/assets/Untitled%2014.B0br3gT7.png",q="/assets/Untitled%2015.BbHGuMSY.png",P="/assets/Untitled%2016.eSf-nMEC.png",S="/assets/Untitled%2017.DdA0iEdM.png",f="/assets/Untitled%2018.Cfgqq2Tb.png",I="/assets/Untitled%2019.CyrwMMsY.png",k="/assets/Untitled%2020.Cx1mxO6g.png",C="/assets/Untitled%2021.03polgnO.png",x="/assets/Untitled%2022.CyhQLV-Z.png",A="/assets/Untitled%2023.87zDgWyB.png",J=JSON.parse('{"title":"C2 指令系统","description":"","frontmatter":{},"headers":[],"relativePath":"计算机体系结构/Chapter2-指令系统.md","filePath":"计算机体系结构/Chapter2-指令系统.md"}'),M={name:"计算机体系结构/Chapter2-指令系统.md"},R=a('<h1 id="c2-指令系统" tabindex="-1">C2 指令系统 <a class="header-anchor" href="#c2-指令系统" aria-label="Permalink to &quot;C2 指令系统&quot;">​</a></h1><h2 id="_2-1-简介" tabindex="-1">2.1 简介 <a class="header-anchor" href="#_2-1-简介" aria-label="Permalink to &quot;2.1 简介&quot;">​</a></h2><ul><li>指令集系统结构：（ Instruction Set Architecture ISA），即计算机硬件对程序员和编译器开发者可见的部分</li><li>现有的各种指令集系统结构设计方案，包括四个方面： （1）指令系统分类的方法 （2）指令系统的分析评价方法 （3）编译器与指令系统结构的相互影响 （4）典型的RISC系统结构---MIPS 64位ISA</li></ul><h2 id="_2-2-指令集系统结构的分类" tabindex="-1">2.2 指令集系统结构的分类 <a class="header-anchor" href="#_2-2-指令集系统结构的分类" aria-label="Permalink to &quot;2.2 指令集系统结构的分类&quot;">​</a></h2><blockquote><p>掌握指令集系统结构分类及特点：堆栈、累加器、通用寄存器</p></blockquote><ul><li><p>不同指令集系统结构最根本的区别：在于处理器内部数据的存储结构不同。</p></li><li><p>操作数可以显式指定或隐式指定</p><ul><li><p>堆栈系统结构中操作数隐含地位于栈顶</p></li><li><p>累加器系统结构中的一个隐含操作数就是累加器。</p></li><li><p>通用寄存器结构系统中只能明确地指定操作数，不是 寄存器就是存储器地址。</p><p><img src="'+e+'" alt="Untitled"></p></li></ul></li><li><p>三种类型详细</p><ul><li>堆栈系统结构 <ul><li>栈顶寄存器（TOS）指向堆栈顶部的输入操作数。</li><li>第一个操作数被从堆栈中删除，运算结果存放在第二个操作数的位置，同时栈顶寄存器指向运算结果。</li><li>所有的操作数都是寄存器，只能通过push或pop指令传输到存储器中</li></ul></li><li>累加器系统结构 <ul><li>即是隐含的输入操作数，也是运算结果</li></ul></li><li>通用寄存器系统结构 <ol><li>一个操作数在寄存器中，另一个在存储器中，运算结果存放在寄存器中。(8086)</li><li>所有的操作数都是寄存器，与堆栈结构（a）类似，也只能通过一些单独的指令（load或store）传输到存储器中.(Mips)</li></ol></li></ul></li><li><p>C=A+B的指令表示</p><p><img src="'+s+'" alt="Untitled"></p><ul><li>在堆栈结构和累加器结构中加法指令的操作数是隐含的，而在寄存器结构中操作数必须明确指定。</li></ul></li></ul><h3 id="_2-2-1-通用寄存器系统结构" tabindex="-1">2.2.1 通用寄存器系统结构 <a class="header-anchor" href="#_2-2-1-通用寄存器系统结构" aria-label="Permalink to &quot;2.2.1 通用寄存器系统结构&quot;">​</a></h3><p>| Register-Memory | Register-Register Load-Store | Memory-Memory | | --- | --- | --- | | 一般指令都可以访问存储期 | 只有load和store可以访问存储期 | 纯mm不存在 |</p><h3 id="_2-2-2-通用寄存器" tabindex="-1">2.2.2 通用寄存器 <a class="header-anchor" href="#_2-2-2-通用寄存器" aria-label="Permalink to &quot;2.2.2 通用寄存器&quot;">​</a></h3><blockquote><p>通用寄存器系统结构的分类及特点</p></blockquote><ul><li><p>原因：比存储器快、位数少、比其他存储形式快</p></li><li><p>根据支持的存储器操作数和ALU的操作数进行分类</p><p><img src="'+o+'" alt="Untitled"></p><ul><li>ALU操作数： <ul><li>3操作数：两源一结果</li><li>2操作数：第二个源是结果</li></ul></li></ul></li></ul><h2 id="_2-3-存储器寻址" tabindex="-1">2.3 存储器寻址 <a class="header-anchor" href="#_2-3-存储器寻址" aria-label="Permalink to &quot;2.3 存储器寻址&quot;">​</a></h2><blockquote><p>基本单位、大小端模式、对齐访问、最常用的寻址方式</p></blockquote><h3 id="_2-3-1-字节寻址" tabindex="-1">2.3.1 字节寻址 <a class="header-anchor" href="#_2-3-1-字节寻址" aria-label="Permalink to &quot;2.3.1 字节寻址&quot;">​</a></h3><ul><li>我们讨论的<strong>所有指令系统</strong>都是字节寻址的，都提供了字节（8位）、半字（16位）和字（32位）寻址，大多数的计算机还提供了双字（64位）寻址。</li><li>在MIPS中，字的起始地址必须是4的倍数。这 叫对齐限制。</li><li>MIPS一个字为4字节，Intel为2字节</li></ul><h3 id="_2-3-2-大小端" tabindex="-1">2.3.2 大小端 <a class="header-anchor" href="#_2-3-2-大小端" aria-label="Permalink to &quot;2.3.2 大小端&quot;">​</a></h3><p><img src="'+r+'" alt="Untitled"></p><h3 id="_2-3-3-对齐" tabindex="-1">2.3.3 对齐 <a class="header-anchor" href="#_2-3-3-对齐" aria-label="Permalink to &quot;2.3.3 对齐&quot;">​</a></h3><ul><li><p>What：假设一个s字节数据的地址是A,如果A mod s=0,访问该地址就是对齐的。</p></li><li><p>Why：</p><ul><li><p>简化硬件实现的复杂性（字或双字整数倍对齐访问存储器）</p></li><li><p>在没有对齐限制的计算机里面，对齐访问的程序也会运行得比较快。</p><p>（一次不对齐的存储器访问：导致多次对齐存储器访问。）</p></li></ul><p><img src="'+p+'" alt="Untitled"></p></li></ul><h3 id="_2-3-4-寻址模式" tabindex="-1">2.3.4 寻址模式 <a class="header-anchor" href="#_2-3-4-寻址模式" aria-label="Permalink to &quot;2.3.4 寻址模式&quot;">​</a></h3><ul><li>立即数通常也被认为是一种存储器寻址方式（<strong>数值在指令流</strong>）</li><li>寄存器不属于存储器寻址</li><li>把依赖于程序计数器的PC相对寻址也分离出来。</li></ul><p><img src="'+n+'" alt="Untitled"></p><ul><li>寻址方式能够减少指令数量，但也增加了计算机的复杂度和平均CPI（ 每条指令的平均周期数（设计寻址模式时可以在VAX上测试基准程序，得出最常用的指令寻址） <ul><li><strong>13-16位的位移量寻址</strong></li><li>小立即数寻址是最常用的，<strong>8~16位立即数是有必要的</strong>。如MIPS和ALPHA采用16位立即数。</li></ul></li><li>一般ISA支持的基本寻址方式 <ul><li>立即数寻址、位移量寻址、寄存器间址。</li></ul></li></ul><h2 id="_2-4-操作数" tabindex="-1">2.4 操作数 <a class="header-anchor" href="#_2-4-操作数" aria-label="Permalink to &quot;2.4 操作数&quot;">​</a></h2><blockquote><p>常用操作数类型</p></blockquote><p><img src="'+d+'" alt="Untitled"></p><ul><li>定点通常是二进制补码表示，字符为ASCII码</li><li>操作数类型的指定方式 <ul><li>操作码的编码 opcode</li><li>硬件解释的字段</li></ul></li><li><strong>在32位地址的计算机中，64位地址将被32位地址取代，定点程序中几乎所有的双字访问都转换成单字访问。</strong></li></ul><h2 id="_2-5-常用指令操作" tabindex="-1">2.5 常用指令操作 <a class="header-anchor" href="#_2-5-常用指令操作" aria-label="Permalink to &quot;2.5 常用指令操作&quot;">​</a></h2><p><img src="'+u+'" alt="Untitled"></p><ul><li>最常用的是前三种</li><li>越常用的执行应越快</li></ul><h3 id="_2-5-1-控制流指令" tabindex="-1">2.5.1 控制流指令 <a class="header-anchor" href="#_2-5-1-控制流指令" aria-label="Permalink to &quot;2.5.1 控制流指令&quot;">​</a></h3><ul><li><p>条件跳转(beq、bne)、跳转jmp、过程调用call、过程返回ret</p></li><li><p>一般要指明目标地址（ret不需要）</p></li><li><p>PC相对寻址</p><ul><li>离得不远，相对寻址缩短指令长度</li><li>位置无关，减少链接工作量</li><li><strong>定点相对寻址转移位移量：至少8位</strong></li></ul></li><li><p>寄存器间接跳转</p><p>为了实现<strong>返回</strong>和<strong>间接跳转</strong>，需要使用寄存器间接跳转：给出包含目标地址的寄存器名称。</p><p>还支持</p><ul><li>分支选择语句case或者switch</li><li>面向对象语言中的虚拟函数或者方法</li><li>高阶函数或者函数指针</li><li>动态共享库</li></ul><p>共同特点：编译时都不知道目标地址，间接跳转之前才把地址从存储器载入到寄存器中。</p></li><li><p>条件转移的可选方案</p><p><img src="'+c+'" alt="Untitled"></p></li><li><p>过程调用的可选方案</p><p><img src="'+_+'" alt="Untitled"></p></li></ul><h2 id="_2-6-指令系统的编码" tabindex="-1">2.6 指令系统的编码 <a class="header-anchor" href="#_2-6-指令系统的编码" aria-label="Permalink to &quot;2.6 指令系统的编码&quot;">​</a></h2><ul><li>指令编码包括：操作、寄存器地址、寻址方式编码。</li><li>指令编码 -&gt;处理器实现和编译后程序大小。</li><li>如何将寻址方式和操作通过编码结合到一起： *如 图B.6，1-5个操作数，10种可能寻址方式，则每个操作数需要一个独立寻址标识符字段（显式）。</li></ul><ul><li>如load/store结构，一个存储器操作数，1-2种寻址方式，则寻址方式由操作编码隐含表示。</li></ul><ul><li><p>对指令编码，需要在以下因素之间找到一个最佳平衡点：</p><p>1、尽可能多的寄存器和寻址方式。 2、寄存器字段、寻址方式字段尽量少，以缩短指令长度。 3、指令长度易于流水线处理。</p></li></ul><h3 id="_2-6-1-三种常见编码格式" tabindex="-1">2.6.1 三种常见编码格式 <a class="header-anchor" href="#_2-6-1-三种常见编码格式" aria-label="Permalink to &quot;2.6.1 三种常见编码格式&quot;">​</a></h3><p><img src="'+h+'" alt="Untitled"></p><ul><li>变长编码：所有操作使用所有寻址模式，适用于寻址模式和操作比较多的情形，不适合流水线。（关注代码量大小）</li><li>定长编码：寻址类型和操作类型整合在opcode里，适合流水线。（执行性能）</li><li>混合：减少过多的指令，又提供扩展性</li></ul><h2 id="_2-7-mips" tabindex="-1">2.7 MIPS <a class="header-anchor" href="#_2-7-mips" aria-label="Permalink to &quot;2.7 MIPS&quot;">​</a></h2><h3 id="_2-7-1-简介" tabindex="-1">2.7.1 简介 <a class="header-anchor" href="#_2-7-1-简介" aria-label="Permalink to &quot;2.7.1 简介&quot;">​</a></h3><ul><li>一种简单64位load-store系统结构</li><li>定长编码</li><li>32个64位通用寄存器，32个浮点寄存器，<strong>R0永远是0</strong></li><li>数据类型： <ul><li>定点：字节、半字、字、双字</li><li>浮点：32位单精度、64位双精度</li></ul></li></ul><h3 id="_2-7-2-mips的寻址" tabindex="-1">2.7.2 MIPS的寻址 <a class="header-anchor" href="#_2-7-2-mips的寻址" aria-label="Permalink to &quot;2.7.2 MIPS的寻址&quot;">​</a></h3><ul><li><p><strong>16位</strong>立即数寻址</p><p><img src="'+g+'" alt="Untitled"></p></li><li><p>寄存器寻址</p><p><img src="'+m+'" alt="Untitled"></p></li><li><p>基址寻址（16位位移量寻址）</p><ul><li>位移量为0：寄存器间接寻址</li></ul><p><img src="'+U+'" alt="Untitled"></p></li><li><p>PC相对寻址</p><p><img src="'+b+'" alt="Untitled"></p></li><li><p>伪直接地址寻址</p><p><img src="'+q+'" alt="Untitled"></p></li></ul><h3 id="_2-7-3-指令格式" tabindex="-1">2.7.3 指令格式 <a class="header-anchor" href="#_2-7-3-指令格式" aria-label="Permalink to &quot;2.7.3 指令格式&quot;">​</a></h3><p><img src="'+P+'" alt="Untitled"></p><ul><li><p>**四大操作：**载入和存储、ALU操作、分支与跳转、浮点操作。</p></li><li><p>所有通用寄存器与浮点数寄存器都可以被载入或存储，唯一的例外是<strong>载入R0无效</strong></p><p><img src="'+S+'" alt="Untitled"></p><ul><li>扩展 <ul><li>当被传送的数据长度不确切时，在符号←上附加一个下标，表示传送n位。</li><li>下标用于标识字段中特定的位。位从以0开始的最高位开始标注。</li><li>上标用来表示对字段进行复制。</li><li>符号##用来链接两个字段并且可以出现在数据传送的任何一边。</li></ul></li></ul></li><li><p>所有ALU都是register-register</p><p><img src="'+f+'" alt="Untitled"></p></li><li><p>控制流指令</p><p><img src="'+I+'" alt="Untitled"></p><ul><li><p><strong>MIPS分支跳转地址</strong></p><p><strong>bpc=16’h address &lt;&lt;2 +（PC+4）</strong></p></li></ul></li><li><p>MOV.S和MOV.D分别把一个单/双精度浮点数寄存器的值复制到另一个同类型的寄存器中</p></li></ul><p>🤔 从ISA分类、指令长度、寻址方式、操作数类型、指令操作类型、指令操作码编码、控制类指令这几个方面说明CISC的8086指令系统与RISC 的32位MIPS指令系统的特点。</p><ul><li>8086指令系统特点：属于<strong>R-M</strong>型ISA，指令长度是<strong>变长</strong>的，寻址方式有寻址字段（立即数、寄存器、直接寻址、寄存器间接寻址、基址寻址、变址寻址、基址变址寻址、串操作寻址、相对寻址、I/O寻址），操作数类型（定点数据类型有字节、16位字、双字、4字，字符串），指令操作类型（传送类、算术运算类、逻辑类、串操作类、程序转移类、处理器控制类），指令操作码编码（1-2个字节编码），转移控制流指令（无条件转移指令直接或间接寻址、条件转移指令和循环控制指令相对寻址、子程序调用与返回指令）。</li><li>MIPS指令系统特点：属于R-R型ISA，指令长度是固定的，寻址方式无专门寻址字段（立即数、位移量寻址、相对寻址），操作数类型（定点数据类型有8位字节、16位半字、32位字和64位双字。浮点数有32位单精度和64位双精度浮点数），指令操作类型（LOAD/STORE类、ALU操作类、分支与跳转类、浮点运算类），指令操作码编码（6位操作码加辅助操作码），转移控制流指令（跳转指令拼接地址、分支指令相对寻址、跳转与链接、寄存器跳转与链接、等于零时转换）。</li></ul><p>🤔 编译器的角色（好玩） 早期：硬件之后开发编译器 现在：处理器设计阶段开发编译器，评估系统结构性能 关注点：指令并行、存储器层次结构</p><p><img src="'+k+'" alt="Untitled"></p><p><img src="'+C+'" alt="Untitled"></p><p><img src="'+x+'" alt="Untitled"></p><p>🤔 谬误（好玩）</p><ol><li>为高级语言设计“高级指令”</li><li>存在典型程序</li><li>可以不考虑编译器而改进指令系统以缩减代码大小。</li><li>有缺陷的系统结构不可能是一种成功的系统结构。</li><li>可以设计一个没有缺陷的系统结构。</li></ol><p><img src="'+A+'" alt="Untitled"></p>',56),D=[R];function T(L,O,B,y,V,E){return t(),i("div",null,D)}const W=l(M,[["render",T]]);export{J as __pageData,W as default};
