import{_ as t,c as i,o as a,a1 as e}from"./chunks/framework.BwTyoF0R.js";const r="/assets/Untitled.BvrmHWZ6.png",l="/assets/Untitled%201.CeXKYrCp.png",p="/assets/Untitled%202.DQE9e2Uw.png",o="/assets/Untitled%203.AHMECW6N.png",s="/assets/Untitled%204.B9ypZi5t.png",n="/assets/Untitled%205.DSadxOvk.png",h="/assets/Untitled%206.BA5jrYGw.png",d="/assets/Untitled%207.Bed617fL.png",c="/assets/Untitled%208.DzS7Yt6i.png",_="/assets/Untitled%209.7TZq_bh7.png",m="/assets/Untitled%2010.qp0OsyO2.png",u="/assets/Untitled%2011.DBIrU1Mj.png",g="/assets/Untitled%2012.DhVW6xw9.png",q="/assets/Untitled%2013.BjPscpNW.png",T=JSON.parse('{"title":"Chapter-3-关联规则挖掘","description":"","frontmatter":{},"headers":[],"relativePath":"数据挖掘与大数据分析/Chapter-3-关联规则挖掘.md","filePath":"数据挖掘与大数据分析/Chapter-3-关联规则挖掘.md"}'),b={name:"数据挖掘与大数据分析/Chapter-3-关联规则挖掘.md"},P=e('<h1 id="chapter-3-关联规则挖掘" tabindex="-1">Chapter-3-关联规则挖掘 <a class="header-anchor" href="#chapter-3-关联规则挖掘" aria-label="Permalink to &quot;Chapter-3-关联规则挖掘&quot;">​</a></h1><h2 id="一、概念" tabindex="-1">一、概念 <a class="header-anchor" href="#一、概念" aria-label="Permalink to &quot;一、概念&quot;">​</a></h2><ol><li><p>目的：在事务、关系数据库中的项集和对象中发现<strong>频繁模式、关联规则、相关性</strong>或<strong>因果架构</strong></p><p><em>频繁模式：数据库中频繁出现的项集</em></p><p>关联规则：X → Y[support, confidence]</p></li><li><p>支持度、置信度</p><p>*支持度：某个项集（A、B同时）出现的比例，*P(A∪B)</p><p><em>置信度：A项出现时，B项出现的比例</em> P(B|A)=P(A∪B)/P(A)</p><p><img src="'+r+'" alt="Untitled"></p><p><img src="'+l+'" alt="Untitled"></p></li><li><p>关联规则挖掘的步骤：频繁项集产生→规则产生</p><ul><li><p><em>Brute-force</em></p><p><img src="'+p+'" alt="Untitled"></p></li></ul></li><li><p>降低产生频繁项集复杂度的方法</p><ol><li>减少候选集的数量——Apriori</li><li>减少比较的次数（压缩…）</li></ol></li></ol><h2 id="二、apriori算法" tabindex="-1">二、Apriori算法 <a class="header-anchor" href="#二、apriori算法" aria-label="Permalink to &quot;二、Apriori算法&quot;">​</a></h2><h3 id="_1-apriori基础概念" tabindex="-1">1. Apriori基础概念 <a class="header-anchor" href="#_1-apriori基础概念" aria-label="Permalink to &quot;1. Apriori基础概念&quot;">​</a></h3><ol><li><p>范式：生成→测试</p><p>k项集→(连接、剪枝)→生成k+1候选项集→根据实际DB进行测试</p></li><li><p>性质</p><p>性质一：如果一个项集是频繁的，那么其所有子集一定频繁</p><p>性质二：如果一个项集是非频繁的，则其所有超集一定是非频繁的</p></li><li><p>剪枝原理</p><p>基于支持度的剪枝：一个项集的支持度不会大于其子集的支持度，即支持度度量的反单调性。</p><p><img src="'+o+'" alt="Untitled"></p></li></ol><h3 id="_2-apriori算法流程" tabindex="-1">2. Apriori算法流程 <a class="header-anchor" href="#_2-apriori算法流程" aria-label="Permalink to &quot;2. Apriori算法流程&quot;">​</a></h3><p><img src="'+s+'" alt="Untitled"></p><p><img src="'+n+'" alt="Untitled"></p><p><img src="'+h+'" alt="Untitled"></p><h3 id="_3-apriori改进策略" tabindex="-1">3. Apriori改进策略 <a class="header-anchor" href="#_3-apriori改进策略" aria-label="Permalink to &quot;3. Apriori改进策略&quot;">​</a></h3><h4 id="_3-1-计算复杂性" tabindex="-1">3.1 计算复杂性 <a class="header-anchor" href="#_3-1-计算复杂性" aria-label="Permalink to &quot;3.1 计算复杂性&quot;">​</a></h4><ol><li>支持度阈值→阈值越低，频繁项集越多、长度越长，计算越复杂</li><li>项数</li><li>事务数→扫描数据库的事务数</li></ol><h4 id="_3-2-改进策略" tabindex="-1">3.2 改进策略 <a class="header-anchor" href="#_3-2-改进策略" aria-label="Permalink to &quot;3.2 改进策略&quot;">​</a></h4><ol><li>减少事务数据库的扫描次数</li><li>压缩候选数量</li><li>便于候选计数</li></ol><h4 id="_3-3-具体方案" tabindex="-1">3.3 具体方案 <a class="header-anchor" href="#_3-3-具体方案" aria-label="Permalink to &quot;3.3 具体方案&quot;">​</a></h4><ol><li><p>Hash-based itemset counting（散列项集计数)</p><p>一个其hash桶计数小于阈值的k项集不可能是频繁的</p><p><img src="'+d+'" alt="Untitled"></p><p><img src="'+c+'" alt="Untitled"></p></li><li><p>Transaction reduction（事务压缩）</p><p>删除不可能对寻找频繁项集有用的事务</p></li><li><p>Partitioning（划分）</p><p>找出局部频繁→得出全局频繁</p><p><img src="'+_+'" alt="Untitled"></p></li><li><p>Sampling（采样/抽样）</p><p>选取数据库中的一个样本，牺牲精度换取有效性。</p><p>扫描一次数据库，验证样本中的频繁模式。</p><p>再次扫描数据库，找出遗漏的频繁模式（可选）。</p></li></ol><h2 id="三、fp增长算法-frequent-pattern-growth-理解" tabindex="-1">三、<em>FP增长算法（Frequent-Pattern Growth）（理解）</em> <a class="header-anchor" href="#三、fp增长算法-frequent-pattern-growth-理解" aria-label="Permalink to &quot;三、*FP增长算法（Frequent-Pattern Growth）（理解）*&quot;">​</a></h2><h3 id="_1-概念" tabindex="-1">1. 概念 <a class="header-anchor" href="#_1-概念" aria-label="Permalink to &quot;1. 概念&quot;">​</a></h3><ul><li>基本思想：将数据组织为紧凑的数据结构，直接从该结果中提取频繁项</li><li>范式：生成FP树并直接寻找频繁项</li></ul><h3 id="_2-流程" tabindex="-1">2.流程 <a class="header-anchor" href="#_2-流程" aria-label="Permalink to &quot;2.流程&quot;">​</a></h3><p>条件模式基→条件FP树→挖取频繁项集 （单路径）</p><p><img src="'+m+'" alt="Untitled"></p><h3 id="_3-优缺点" tabindex="-1">3. 优缺点 <a class="header-anchor" href="#_3-优缺点" aria-label="Permalink to &quot;3. 优缺点&quot;">​</a></h3><ul><li>优点：效率比Apriori高</li><li>缺点：内存需求大，算法实现复杂</li></ul><h2 id="四、关联规则的评估-理解" tabindex="-1">四、关联规则的评估（理解） <a class="header-anchor" href="#四、关联规则的评估-理解" aria-label="Permalink to &quot;四、关联规则的评估（理解）&quot;">​</a></h2><ol><li><p>根据统计论据建立</p><p>涉及相互独立的项或覆盖少量事务的模式被认为是不令人感兴趣的，因为它们可能反映数据中的伪联系。</p></li><li><p>根据主观论据建立</p><p>挖掘“有趣”的规则，强规则不一定是有趣的，甚至是误导的</p></li></ol><p><img src="'+u+'" alt="Untitled"></p><p><img src="'+g+'" alt="Untitled"></p><p><img src="'+q+'" alt="这里的支持度为后件的支持度"></p><p>这里的支持度为后件的支持度</p>',31),f=[P];function U(A,k,x,B,C,D){return a(),i("div",null,f)}const w=t(b,[["render",U]]);export{T as __pageData,w as default};
