import{_ as l,c as i,o as a,a1 as e}from"./chunks/framework.BwTyoF0R.js";const t="/assets/Untitled%2082.DoaGsALH.png",r="/assets/Untitled%2083.0_HkzfPd.png",o="/assets/Untitled%2084.DLWyq_WP.png",p="/assets/Untitled%2085.Cp8xE45g.png",s="/assets/Untitled%2086.B3htRkTM.png",n="/assets/Untitled%2087.C-1uPlUG.png",d="/assets/Untitled%2088.CtVLAlW2.png",h="/assets/Untitled%2089.CWAKYfNo.png",c="/assets/Untitled%2090.CmfTpxQc.png",u="/assets/Untitled%2091.DrsnBlSG.png",m="/assets/Untitled%2092.DAnohJ6r.png",U=JSON.parse('{"title":"第五章 Windows病毒","description":"","frontmatter":{},"headers":[],"relativePath":"病毒理论/Chapter5.md","filePath":"病毒理论/Chapter5.md"}'),_={name:"病毒理论/Chapter5.md"},b=e('<h1 id="第五章-windows病毒" tabindex="-1">第五章 Windows病毒 <a class="header-anchor" href="#第五章-windows病毒" aria-label="Permalink to &quot;第五章 Windows病毒&quot;">​</a></h1><p>头插入结果：文件太大</p><p>尾插入结果：病毒代码根本没进内存</p><h2 id="com-vs-exe" tabindex="-1">Com vs Exe <a class="header-anchor" href="#com-vs-exe" aria-label="Permalink to &quot;Com vs Exe&quot;">​</a></h2><ol><li>com默认加载到100h，exe不知道加载到哪</li><li>Exe的大小问题？</li></ol><h2 id="保护模式" tabindex="-1">保护模式 <a class="header-anchor" href="#保护模式" aria-label="Permalink to &quot;保护模式&quot;">​</a></h2><ul><li>每个进程都有自己的线性地址空间</li><li>对于程序的加载：不同模块加载地址不同，需要有地方存储约定的加载地址</li></ul><h2 id="pe格式" tabindex="-1">PE格式 <a class="header-anchor" href="#pe格式" aria-label="Permalink to &quot;PE格式&quot;">​</a></h2><p><img src="'+t+'" alt="Untitled"></p><ul><li>RVA:加载后相对于整个PE文件首部的偏移量 <ul><li><p>和文件偏移不同，是加载后在内存中的偏移</p></li><li><p>有的段可能相同有的段可能不同</p><p><img src="'+r+'" alt="Untitled"></p></li></ul></li></ul><h2 id="如何执行病毒" tabindex="-1">如何执行病毒 <a class="header-anchor" href="#如何执行病毒" aria-label="Permalink to &quot;如何执行病毒&quot;">​</a></h2><ol><li><p>通过DosHeader找到NT头部</p><ol><li>Magic</li><li>e_lfanew指示NT头部的起始偏移</li></ol></li><li><p>需要找到程序的入口地址(在NT头部)</p></li><li><p>OD修改入口地址</p><p>通过RVA查看所属段的RVA与文件偏移是否有偏差，有就要调整</p></li></ol><h2 id="如何加载病毒" tabindex="-1">如何加载病毒 <a class="header-anchor" href="#如何加载病毒" aria-label="Permalink to &quot;如何加载病毒&quot;">​</a></h2><ol><li><p>简单粘贴在尾部不能加载，可能存在相关字段</p><p>总大小和每个段的大小都有参数，分别在IMAGE_Option_HEADER和各个IMAGE_SECTION_HEADER中。 其大小应该是SectionAlign（也是OptionHeader中的字段，即内存的对齐单位）的整数倍</p></li><li><p>选取最后一个段进行病毒的写入</p><ol><li>如果该段的内存大小小于磁盘大小，将指令直接加载到多余部分，修改内存大小VirtualSize</li><li>如果该段的大内存大小大于或等于磁盘大小，则将指令粘贴到段后，然后修改段内存大小VirtualSize和段文件大小SizeofRawData。</li></ol></li><li><p>修改ImageSize为新大小</p><p>要注意的是，有时exe最后段后有一些调试信息，但它不会被加载到内存。这也许是ImageSize的意义，它阻止尾部多余信息进入内存</p></li><li><p>这下修改入口点就可以启动了</p></li><li><p>需要返回原程序</p><p><img src="'+o+'" alt="Untitled"></p></li></ol><h2 id="修改入口点的问题" tabindex="-1">修改入口点的问题 <a class="header-anchor" href="#修改入口点的问题" aria-label="Permalink to &quot;修改入口点的问题&quot;">​</a></h2><blockquote><p>入口点在代码区之外</p></blockquote><p>解决思路（入口点模糊）：</p><ol><li><p>感染代码段</p><p><img src="'+p+'" alt="Untitled"></p></li><li><p>不修改入口点，将入口点第一行代码替换为jmp指令</p><p><img src="'+s+'" alt="Untitled"></p><ul><li>实际操作过程中 <ul><li>可能遇到内存权限问题</li></ul></li></ul></li></ol><h2 id="系统如何提供api" tabindex="-1">系统如何提供API <a class="header-anchor" href="#系统如何提供api" aria-label="Permalink to &quot;系统如何提供API&quot;">​</a></h2><ul><li>通过动态链接库对外提供api</li></ul><h2 id="如何获取api的入口地址" tabindex="-1">如何获取api的入口地址 <a class="header-anchor" href="#如何获取api的入口地址" aria-label="Permalink to &quot;如何获取api的入口地址&quot;">​</a></h2><ul><li><p>常规方法</p><ul><li><p>获取提供函数的dll的加载基址</p><ul><li>通过peb获取，有一个加载模块链表（环形链表）</li></ul></li><li><p>理解dll的导出表机制，并获取函数地址</p><ul><li>导出表的地址由NT头记录</li><li>可以通过函数名命名，也可以通过序号命名</li><li>需要知道序号的最小值x</li><li>函数名表-函数地址索引表-函数地址表</li><li>PE格式的函数名表是函数指针表，存着函数名的首地址RVA</li></ul><p><img src="'+n+'" alt="Untitled"></p><p><img src="'+d+'" alt="Untitled"></p></li></ul></li><li><p>简易方法</p><ul><li>进程加载的所有系统dll基址相同</li><li>感染程序直接调用系统api即可获得一样的基址</li></ul></li></ul><h2 id="导入表感染" tabindex="-1">导入表感染 <a class="header-anchor" href="#导入表感染" aria-label="Permalink to &quot;导入表感染&quot;">​</a></h2><ul><li>函数调用采用call相对偏移进行</li></ul><p><img src="'+h+'" alt="Untitled"></p><h3 id="导入表-iat" tabindex="-1">导入表 IAT <a class="header-anchor" href="#导入表-iat" aria-label="Permalink to &quot;导入表 IAT&quot;">​</a></h3><ul><li>NT头部→Import Description Table→Import Description→dll name、int table RVA和IAT table RVA</li></ul><p><img src="'+c+'" alt="Untitled"></p><ul><li>INT ：Import Name Table</li><li>IAT：Import Address Table</li></ul><p><img src="'+u+'" alt="Untitled"></p><h3 id="绑定导入-预先绑定" tabindex="-1">绑定导入（预先绑定） <a class="header-anchor" href="#绑定导入-预先绑定" aria-label="Permalink to &quot;绑定导入（预先绑定）&quot;">​</a></h3><p><a href="https://blog.csdn.net/weixin_37673331/article/details/104584969" target="_blank" rel="noreferrer">PE结构（四） 绑定导入表_吾乃花花的博客-CSDN博客</a></p><ul><li>预先绑定：直接使用绝对地址（系统dll的基址固定且可知）</li><li>需注意 <ul><li>只有IAT，则必然是INT的RVA，否则无法导入</li><li>预先绑定必然有INT</li><li>有INT用INT，否则用IAT</li></ul></li></ul><h3 id="dep数据执行保护" tabindex="-1">dep数据执行保护 <a class="header-anchor" href="#dep数据执行保护" aria-label="Permalink to &quot;dep数据执行保护&quot;">​</a></h3><p>eip指向数据段时，报内存访问错误</p><ul><li>绕过方法 <ul><li>将段属性加上可执行，系统会认为是代码区</li><li>关闭dep</li></ul></li></ul><h3 id="重定位" tabindex="-1">重定位 <a class="header-anchor" href="#重定位" aria-label="Permalink to &quot;重定位&quot;">​</a></h3><p>需要重定位的地址记录在重定位表内</p><h2 id="导入表替换感染" tabindex="-1">导入表替换感染 <a class="header-anchor" href="#导入表替换感染" aria-label="Permalink to &quot;导入表替换感染&quot;">​</a></h2><ul><li>让原导入表全部指向病毒开始，而新造一个导入表项，让系统将导入函数填写到该处。这样就能保证程序正常执行</li></ul><p><img src="'+m+'" alt="Untitled"></p><h2 id="rtl表感染" tabindex="-1">RTL表感染 <a class="header-anchor" href="#rtl表感染" aria-label="Permalink to &quot;RTL表感染&quot;">​</a></h2><ul><li>RTL是程序的运行时库，比如printf就是运行时库的一部分。</li><li>对C编写的程序，其真正入口并非我们看见的源码中main，而是RTL的初始化代码。它是必然存在的，可以作为感染对象。</li><li>这实际是通过特征代码判断出RTL初始化代码所在，然后对判别出的代码进行patch</li><li>对于不识别的RTL，或没用RTL的库，无法感染。</li></ul><h3 id="crt" tabindex="-1">CRT <a class="header-anchor" href="#crt" aria-label="Permalink to &quot;CRT&quot;">​</a></h3><ul><li>查找特征码</li></ul>',45),q=[b];function T(f,x,P,g,A,k){return a(),i("div",null,q)}const R=l(_,[["render",T]]);export{U as __pageData,R as default};
